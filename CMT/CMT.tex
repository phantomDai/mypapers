\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{enumerate}
\usepackage{multirow}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}


\newcommand{\rmnum}[1]{\expandafter{\romannumeral #1\relax}}
\begin{document}

\title{* Metamorphic Testing*\\
%{\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and
%should not be used}
%\thanks{Identify applicable funding agency here. If none, delete this.}
\thanks{The National Natural Science Foundation of China (under Grant No. 61872039),
the Beijing Natural Science Foundation (Grant No. 4162040),
the Aeronautical Science Foundation of China (Grant No. 2016ZD74004), and
the Fundamental Research Funds for the Central Universities (Grant No. FRF-GF-17-B29).}
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Peng~Wu}
\IEEEauthorblockA{\textit{a State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences} \\
\textit{University of Chinese Academy of Sciences}\\
Beijing, China \\
wp@ios.ac.cn}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Hepeng~Dai}
\IEEEauthorblockA{\textit{School of Computer and Communication Engineering} \\
\textit{University of Science and Technology Beijing}\\
Beijing, China \\
daihepeng@sina.cn}
\and
\IEEEauthorblockN{3\textsuperscript{st} Chang-ai~Sun,~\IEEEmembership{Senior Member,~IEEE,}}
\IEEEauthorblockA{\textit{School of Computer and Communication Engineering} \\
\textit{University of Science and Technology Beijing}\\
Beijing, China \\
casun@ustb.edu.cn}
}

\maketitle

\begin{abstract}
  Metamorphic testing (MT) is a promising technique to alleviate the oracle problem, which fist defines metamorphic relations (MRs) used to generate new test cases (i.e. follow-up
  test cases) from the original test cases (i.e. source test cases). Both source and follow-up test cases are executed and their results are verified against the relevant MRs.

\end{abstract}

\begin{IEEEkeywords}
metamorphic testing, control test process, partition
\end{IEEEkeywords}

\section{Introduction}
\label{section:introduction}
Test result verification is an important part of software testing. A test oracle \cite{weyuker1982testing} is mechanism that can exactly decide whether or not the output
produced by a programs is correct. However, there are situations, where it is difficult to decide whether the result of the software under test (SUT) agrees with the expected
result. This situation is known as oracle problem \cite{barr2015oracle, patel2018mapping}.

Metamorphic testing (MT) \cite{chen1998metamorphic, chen2018metamorphic} is one of several techniques to alleviate oracle problem. MT first define metamorphic relations (MRs)
through using some properties of SUT. Then, MRs are used to generate new test cases called follow-up test cases from original test cases known as source test cases. Next,
both source and follow-up test cases are executed and their result are verified against the corresponding MRs.



\section{Background}
In this section, we present the basics to understand our approach. we start with a brief introduction to metamorphic testing, and then describe dynamic random testing.
\label{section:background}
\subsection{Metamorphic Testing}
\label{section:mt}
A test oracle is a mechanism used to verify the correctness of outputs of a program \cite{weyuker1982testing}. However, there are test oracle problem
\cite{barr2015oracle, patel2018mapping} in testing, that is, there are not an oracle or the application of such an oracle is very expensive. In order to alleviate the test oracle,
several techniques have been proposed such as N-version testing \cite{brilliant1990performance}, metamorphic testing (MT) \cite{chen1998metamorphic},
assertions \cite{sim2014eliminating}, machine learning \cite{chan2009pat}, etc. Among of them, MT obtains metamorphic relations (MRs) according to the properties of software
under test (SUT). MRs are used to generate follow-up test cases from source test cases, then the both source and follow-up test cases are executed, and their results are
verified against the corresponding MRs. If an MR is violated, that is, a fault is detected.

Let us use a simple example to illustrate how MT works. For instance, consider the mathematic function $f(x,y)$ that can calculate the maximal value of two integers $x$ and $y$.
There is a simple and obvious property: the order of two parameters $x$ and $y$ does not affect the output, which can be described as the follow metamorphic relation
(MR): $f(x,y) = f(y,x)$. In this MR, $(x,y)$ is source test case, and $(y,x)$ is considered as follow-up test case. Letting $P$ denotes a program that implements the
function $f(x,y)$. Suppose $P$ is executed with a test case $(1,2)$, giving an output of 2. With respect to the MR $f(x,y) = f(y,x)$, $P$ should next be executed with
the other test case $(2,1)$. Then the output of second execution is compared with that of the first test case: does $P(1,2) = P(2,1)$? If the equality does not hold, then
we consider that $P$ at least has one fault.


\section{Empirical Study}
\label{section:empirical}
We have conducted a series of empirical studies to evaluate the performance of M-AMT. The design of experiments is described in this section.

\subsection{Research Questions}
\label{section:questions}

\begin{description}
  \item [RQ1]
  How efficient and effective MT is at detecting faults of concurrent programs?
  Fault-detection efficiency and effectiveness are key criterions for evaluating the performance of a testing technique. In our study, we chose five real-life programs, and applied mutation analysis to evaluate them. 
  \item [RQ2]
  How is the fault-detecting capability of each metamorphic relationship? 
  
  \item [RQ3]
  How many metamorphic relations can detect most of faults existing in concurrent programs?
  
  \item [RQ4]
  How does the number of threads affect fault-detecting capability of MT?
  
  \item [RQ5]
  What is the actual test cases execution overhead when using MT to detect the faults of concurrent programs?

\end{description}


\section{Related Work}
\label{section:related}
In this section, we describe related work of MT.

\subsection{Metamorphic Testing}
When testing a software system, the oracle problem appears in some situations where either an oracle does not exist for the tester to verify the correctness of the computed results; or an oracle does exist but cannot be used. The oracle problem often occurs in software testing, which renders many testing techniques inapplicable \cite{barr2015oracle}. To alleviate the oracle problem, Chen et al. \cite{chen1998metamorphic} proposed a technique named metamorphic testing (MT) that has been receiving increasing attention in the software testing community\cite{barr2015oracle, segura2016survey, chen2018metamorphic}. The main contributions to MT in the literature focused on the following aspects: \rmnum{1}) MT theory; \rmnum{2}) combination with other techniques; \rmnum{3}) application of MT.
\begin{enumerate}[1]
  \item
  \emph{Theoretical development of MT:} The MRs and the source test cases are the most important components of MT. However, defining MRs can be difficult. Chen et al. \cite{chen2016metric} proposed a specification-based method and developed a tool called MR-GENerator for identifying MRs based on category-choice framework\cite{ostrand1988category}.
  Zhang et al. \cite{zhang2014search} proposed a search-based approach to automatic inference of polynomial MRs for a software under test, where a set of parameters is used to represent polynomial MRs, and the problem of inferring MRs is turn into a problem of searching for suitable values of the parameters. Then, particle swarm optimization is used to solve the search problem.
  Sun et al. \cite{sun2016mumt} proposes a data-mutation directed metamorphic relation acquisition methodology, in which data mutation is employed to construct input relations and the generic mapping rule associated with each mutation operator to construct output relations.
  Liu et al. \cite{liu2012new} proposed to systematically construct MRs based on some already identified MRs.

  Without doubt, ``good'' MRs can improve the fault detection efficiency of MT.
  Chen et al. \cite{chen2004case} reported that good MRs are those that can make the execution of the source-test case as different as possible to its follow-up test case.
  This perspective has been confirmed by the later studies \cite{dong2013security, batra2011efficient}.
  Asrafi et al. \cite{asrafi2011testing} conduct a case study to analyze the relationship between the execution behavior and the fault-detection effectiveness of metamorphic relations by code coverage criteria, and the results showed a strong correlation between the code coverage achieved by a metamorphic relation and its fault-detection effectiveness.

  Source test cases also have a important impact on the fault detection effectiveness of MT.
  Chen et al. \cite{chen2004metamorphic} compared the effects of source test cases generated by special value testing and random testing on the effectiveness of MT, and found that MT can be used as a complementary test method to special value testing.
  Batra and  Sengupta \cite{batra2011efficient} integrated genetic algorithms into MT to select source test cases maximising the the paths traversed in the software under test.
  Dong et al. \cite{dong2013security} proposed a Path--Combination--Based MT method that first generates symbolic input for each executable paths and minis relationships among these symbolic inputs and their outputs, then constructs MRs on the basis of these relationships, and generates actual test cases corresponding to the symbolic inputs.

  Different from the above investigates, we focused on performing test cases and MRs with fault revealing capabilities as quickly as possible by making use of feedback information. We first divided the input domain into disjoint partitions, and randomly selected an MR to generate follow-up test cases depended on source test case of related input partitions, then updated the test profile of input partitions according to the results of test execution. Next, a partition was selected according to updated test profile, and an MR was randomly selected from the set of MRs whose source test cases belong to selected partition.
  \item
  \emph{Combination with other techniques:} In order to improve the applicability and effectiveness of MT, it has been integrated into other techniques.
  Xie et al. \cite{xie2013metamorphic} combined the MT with the spectrum-based fault localization (SBFL), extend the application of SBFL to the common situations where test oracles do not exist.
  Dong et al. \cite{dong2010security} proposed a method for improving the efficiency of evolutionary testing (ET) by considering MR when fitness function is constructed.
  Liu et al. \cite{liu2014metamorphic} introduced MT into fault tolerance and proposed a theoretical framework of a new technique called Metamorphic Fault Tolerance (MFT), which can
  handle system failure without the need of oracles during failure detection. In MFT, the trustworthiness of a test case depends on the number of violations or satisfactions of metamorphic relations. The more relations are satisfied and the less relations are violated, the more trustable test case is.
  \item
  \emph{Application of MT:}
  Sun et al. \cite{sun2011metamorphic, sun2012metamorphic} proposed a metamorphic testing framework for web services taking into account the unique features of SOA, in which MRs are derived from the description or Web Service Description Language (WSDL) \cite{sun2011metamorphic} of the Web service, and on the basis on of MRs, follow-up test cses are generated depended on source test cases that are randomly generated according to the WSDL.
  Segura et al. \cite{segura2018metamorphic} present a metamorphic testing approach for the detection of faults in RESTful Web APIs where they proposed six abstract relations called Metamorphic Relation Output Patterns (MROPs) that can then be instantiated into one or more concrete metamorphic relations. To evaluate this approach, they used both automatically seeded and real faults in six subject Web APIs.

\end{enumerate}



\section{Conclusion}
\label{section:conclusion}


In our future work, we plan to conduct experiments on more real-life programs to further validate the effectiveness of MT, and identify the limitations of our approach.

\section*{Acknowledgment}


\newcommand{\BIBdecl}{\setlength{\itemsep}{0.2 em}}

\bibliographystyle{IEEEtran}
\bibliography{CMT}


\end{document}
