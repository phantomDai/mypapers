\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{amsthm}
\theoremstyle{remark}
\newtheorem*{rmk*}{Remark}
\usepackage{algorithm,algcompatible}
%\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{enumerate}
\usepackage{multirow}
\usepackage{booktabs}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\usepackage{subfigure}

\newcommand{\rmnum}[1]{\expandafter{\romannumeral #1\relax}}
\newcommand{\Fn}{\textsc{Top}}
\newcommand{\MR}{\textit{MR}}

\begin{document}

\title{Towards Metamorphic Testing of Concurrent Programs\\
%{\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and
%should not be used}
%\thanks{Identify applicable funding agency here. If none, delete this.}
\thanks{The National Natural Science Foundation of China (under Grant No. 61872039),
the Beijing Natural Science Foundation (Grant No. 4162040),
the Aeronautical Science Foundation of China (Grant No. 2016ZD74004), and
the Fundamental Research Funds for the Central Universities (Grant No. FRF-GF-17-B29).}
}

\author{\IEEEauthorblockN{Peng~Wu}
\IEEEauthorblockA{\textit{State Key Laboratory of Computer Science} \\
\textit{Institute of Software, Chinese Academy of Sciences} \\
\textit{University of Chinese Academy of Sciences}\\
Beijing, China, wp@ios.ac.cn}
\and
\IEEEauthorblockN{Hepeng~Dai}
\IEEEauthorblockA{\textit{School of Computer and Communication Engineering} \\
\textit{University of Science and Technology Beijing}\\
Beijing, China \\
daihepeng@sina.cn}
\and
\IEEEauthorblockN{Tsong Yueh Chen}
\IEEEauthorblockA{\textit{Department of Computer Science and Software Engineering} \\
\textit{Swinburne University of Technology}\\
Melbourne, Australia \\
tychen@swin.edu.au}
\and
\IEEEauthorblockN{Chang-ai~Sun,~\IEEEmembership{Member,~IEEE}}
\IEEEauthorblockA{\textit{School of Computer and Communication Engineering} \\
\textit{University of Science and Technology Beijing}\\
Beijing, China \\
casun@ustb.edu.cn}
}

\maketitle

\begin{abstract}
  Metamorphic testing (MT) is a promising technique to alleviate the oracle problem, which fist defines metamorphic relations (MRs) used to generate new test cases (i.e. follow-up
  test cases) from the original test cases (i.e. source test cases). Both source and follow-up test cases are executed and their results are verified against the relevant MRs.

\end{abstract}

\begin{IEEEkeywords}
metamorphic testing, control test process, partition
\end{IEEEkeywords}

\section{Introduction}
\label{section:introduction}
A concurrent program typically forks multiple threads that run concurrently to fulfill a functional task, e.g., computing, sorting, or searching a large volume of static or dynamic data with presumably high speedup. Different threads may interact with each other through shared variables, which require rigorously lock-based or lock-free synchronizations. An explicit lock can enforce a mutually exclusive access to a shared variable, while a lock-free primitive, such as {\it compare-and-swap}, can ensure an atomic access to a shared variable. Thus, an execution of a concurrent program would highly depend on the runtime thread scheduling, which is nondeterministic by nature. Therefore, it is still challenging to efficiently detect faults, especially concurrency faults, in multi-threaded concurrent programs. Furthermore, test oracles \cite{weyuker1982testing} play a fundamental role in determining the correctness of an output produced by a program under test (PUT). However, due to the vast possibilities of thread scheduling, it can be very difficult or expensive, if not impossible, to determine the expected output of a concurrent program \textit{a priori}. This oracle problem \cite{barr2015oracle, patel2018mapping} arises for concurrent programs inevitably.

Metamorphic testing (MT) \cite{chen1998metamorphic, chen2018metamorphic} has been a successful technique to tackle oracle problems in various applications such as compilers \cite{LAS14}, search engines \cite{7254235}, cybersecurity \cite{CKMSTVZ6} and machine learning-based driverless cars \cite{ZS19}. MT relies on metamorphic relations (MRs) that are derived from the necessary properties or user expectations about the inputs and outputs of the program under test. For instance, consider the function $max(x,y)$ that returns the maximum value between $x$ and $y$. Obviously, it is commutative, i.e., the order of the two parameters $x$ and $y$ does not affect its result. This property can be identified as a metamorphic relation $\MR_{max}: max(x,y) = max(y,x)$, where $(x,y)$ constitutes a source test case, and $(y,x)$ is the follow-up test case resulted by directly swapping the two parameters of the source test case. Then, for a program $P_{max}(x,y)$ that implements the function $max(x,y)$, if the outputs of $P_{max}$ under the source test case $(x,y)$ and the follow-up test case $(y,x)$ do not equal, i.e, $P_{max}(x,y)\neq P_{max}(y,x)$, a fault is thus detected in this program.

It can be seen that MRs are referred to in the two stages of MT: test case generation and test case execution. In the former stage, a follow-up test case can be generated, based on an MR, from an original test case (i.e., a source test case) with or without taking into account the output of the PUT under the source test case; while in the latter stage, the outputs of the PUT under both the source and the follow-up test cases can be inspected against the MR. If the MR is violated, then the PUT is shown to be incorrect, as witnessed by the executions of the source and follow-up test cases.

In this paper, we intend to investigate the fault detection effectiveness of a metamorphic relation in concurrent testing. On one hand, a concurrent program may fulfill a functional task in a more efficient manner than a correspondingly sequential one may, e.g., by taking advantages of multicore processors, while on the other hand, a sequential program can be regarded as a special concurrent program where all the threads run in the pre-specified sequential order. This suggests that metamorphic relations identified based on the functional requirements or user expectations of the task shall apply to any of its implementation, no matter which is sequential or concurrent. That is, these \emph{functional} metamorphic relations may be exploited to validate the nondeterministic outputs of a concurrent program with multiple inputs. But it is not clear how their fault detection effectiveness in testing a concurrent implementation would differ from that in testing a sequential one, as multiple threads running concurrently may trigger more subtle behaviors in the underlying implementation. Moreover, concurrency faults related to synchronizations only occur in a concurrent implementation, while it is not clear how the metamorphic relations would take effect in detecting these concurrency faults. 

Herein we will address these issues through an empirical study with the Top-$k$ query problem, i.e., searching for the least or greatest $k$ elements in a large data repository. It is a quite typical problem in big data processing. In this work we consider a collection of concurrent programs that utilize a concurrent implementation of priority queue as the underlying data structure to solve the query problem. Each concurrent program consists of multiple threads that share a concurrent priority queue object as the data repository, inserting an element into the queue or removing the least or greatest element from the queue concurrently. We also include correspondingly sequential programs, which insert and remove elements sequentially, as the baseline to demonstrate the effectiveness of the functional metamorphic relations in detecting ordinary and concurrency faults.

%aim at investigating the applicability of metamorphic testing to concurrent programs. This is motivated by the observation that the functional requirement or user expectation to a concurrent program can be identified as metamorphic relations for verifying the outputs of its nondeterministic executions under different inputs.

The rest of the paper is organized as follows.

\section{Metamorphic Testing of Concurrent Programs}
\subsection{Concurrent Programs}

Without loss of generality, let $\mathbb{D}$ be a value domain with a total order $\leq$ defined on it.
Consider a search function \Fn$(V,k)$ that accepts a multiset $V$ of values from $\mathbb{D}$ and returns %in the strictly ascending order 
the least distinct $k>0$ values in $V$. Note that $V$ may contain duplicate values, but \Fn$(V,k)$ may not. In case that the size of $V$ is very large, it is rather time-consuming to validate the results of a program that implements \Fn$(V,k)$.

Apparently this function can be implemented in a straightforward way, i.e., all the values in $V$ are  stored in a data repository $q$ (as shown in Algorithm~\ref{alg:sa}), followed by repeatedly removing and collecting the least value in the current repository until $k$ distinct values are collected (as shown in Algorithm~\ref{alg:sr}). A \emph{priority queue} object is typically utilized herein as the data repository for better search efficiency. Its add($x$) method inserts value $x$ into the repository, while its removeMin() method removes and returns the least value in the repository.

Concurrent data structures \cite{PQUEUE} have been developed to further take advantages of multi-processor architectures that are already very popular nowadays. A concurrent priority queue object  can then be utilized as the data repository ($q$) to be shared by multiple threads, which concurrently insert values into the queue (as shown in Algorithm~\ref{alg:ca}), or concurrently remove values from the queue (as shown in Algorithm~\ref{alg:cr}). In Algorithms~\ref{alg:ca} and \ref{alg:cr}, the iterations in each \textbf{parallel-for} loop run concurrently with separate $t>1$ threads. 

\algblockdefx{PARFOR}{ENDPARFOR}[1]%
  {\textbf{parallel for} #1 \textbf{do}}%
  {\textbf{end parallel for}}
\newcommand{\Q}{$q$}

\begin{minipage}[t]{.45\linewidth}
%\vspace{0pt} 
\begin{algorithm}[H]
\caption{sequentialAdd($V$)}
\label{alg:sa}
\begin{algorithmic}[1]
\FORALL {$x$ in $V$}
\STATE \Q.add($x$);
\ENDFOR
\end{algorithmic}
\end{algorithm}
\end{minipage}
~
\begin{minipage}[t]{.48\linewidth}
%\vspace{0pt} 
\begin{algorithm}[H]
\caption{concurrentAdd($V$)}
\label{alg:ca}
\begin{algorithmic}[1]
\STATE Partition $V$ into $t$ disjoint parts $V_1,\ldots,V_t$;
\PARFOR {$i\gets 1$ to $t$}
\STATE sequentialAdd($V_i$);
\ENDPARFOR
\end{algorithmic}
\end{algorithm}
\end{minipage}

\begin{minipage}[t]{.45\linewidth}
%\vspace{0pt} 
\begin{algorithm}[H]
\caption{sequentialRemove($k$)}
\label{alg:sr}
\begin{algorithmic}[1]
\STATE $R\gets\emptyset$;
\REPEAT
\STATE	$x\gets$ \Q.removeMin();
\IF {$x\not\in R$}
\STATE $R\gets R\cup\{x\}$;
\ENDIF
\UNTIL {$|R|=k$}
\STATE \textbf{return} {$R$};
\end{algorithmic}
\end{algorithm}
\end{minipage}
~
\begin{minipage}[t]{.48\linewidth}
%\vspace{0pt} 
\begin{algorithm}[H]
\caption{concurrentRemove($k$)}
\label{alg:cr}
\begin{algorithmic}[1]
\STATE $R\gets\emptyset$;
\PARFOR {$i\gets 1$ to $t$}
\STATE $c_i\gets 0$;
\REPEAT
\STATE	$x\gets$ \Q.removeMin();
\IF {$x\not\in R$}
\STATE $R\gets R\cup\{x\}$;
\STATE $c_i\gets c_i+1$;
\ENDIF
\UNTIL {$c_i=k/t$}
\ENDPARFOR
\STATE \textbf{return} {$R$};
\end{algorithmic}
\end{algorithm}
\end{minipage}

Thus, there exist four categories of implementations for function \Fn$(V,k)$
\begin{enumerate}
\item SASR$(V,k)$ sequentially insert values to the data repository, followed by sequentially removing the least values from the data repository, as shown in Algorithm~\ref{alg:sasr}.
\item SACR$(V,k)$ sequentially insert values to the data repository, followed by concurrently removing the least values from the data repository, as shown in Algorithm~\ref{alg:sacr}.
\item CASR$(V,k)$ concurrently insert values to the data repository, followed by sequentially removing the least values from the data repository, as shown in Algorithm~\ref{alg:casr}.
\item CACR$(V,k)$ concurrently insert values to the data repository, followed by concurrently removing the least values from the data repository, as shown in Algorithm~\ref{alg:cacr}.
\end{enumerate}

\begin{minipage}[t]{.45\linewidth}
%\vspace{0pt} 
\begin{algorithm}[H]
\caption{SASR($V,k$)}
\label{alg:sasr}
\begin{algorithmic}[1]
\STATE sequentialAdd(V);
\STATE \textbf{return} {sequentialRemove($k$)};
\end{algorithmic}
\end{algorithm}
\end{minipage}
~
\begin{minipage}[t]{.45\linewidth}
%\vspace{0pt} 
\begin{algorithm}[H]
\caption{SACR($V,k$)}
\label{alg:sacr}
\begin{algorithmic}[1]
\STATE sequentialAdd(V);
\STATE \textbf{return} {concurrentRemove($k$)};
\end{algorithmic}
\end{algorithm}
\end{minipage}

\begin{minipage}[t]{.45\linewidth}
%\vspace{0pt} 
\begin{algorithm}[H]
\caption{CASR($V,k$)}
\label{alg:casr}
\begin{algorithmic}[1]
\STATE concurrentAdd(V);
\STATE \textbf{return} {sequentialRemove($k$)};
\end{algorithmic}
\end{algorithm}
\end{minipage}
~
\begin{minipage}[t]{.45\linewidth}
%\vspace{0pt} 
\begin{algorithm}[H]
\caption{CACR($V,k$)}
\label{alg:cacr}
\begin{algorithmic}[1]
\STATE concurrentAdd(V);
\STATE \textbf{return} {concurrentRemove($k$)};
\end{algorithmic}
\end{algorithm}
\end{minipage}

In this work, we use the 5 concurrent priority queue classes: \texttt{SimpleLinear}, \texttt{SimpleTree}, \texttt{SequentialHeap}, \texttt{FineGrainedHeap}, and \texttt{SkipQueue}, presented in the textbook \cite{PQUEUE} to implement the above algorithms. The \texttt{SimpleLinear} class is an array-based bounded implementation, while the \texttt{SimpleTree} class is a tree-based one. The \texttt{SequentialHeap} class is a coarse-grained implementation based on a unbounded heap, while the \texttt{FineGrainedHeap} class is a fine-grained one. These classes all explicitly use locks for synchronization, except the \texttt{SkipQueue} class, which is based on a skiplist that uses an atomic primitive (i.e., compareAndSet) for synchronization.

\subsection{Metamorphic Relations}
Let $VW$ be the concatenation of lists $V$ and $W$, and $V^k$ the concatenation of $k$ $V$'s. Let $head(V)$ denote the first element of list $V$, and $tail(V)$ the list resulted by removing the first element of list $V$. Therefore, $V=head(V)::tail(V)$. The higher-order function  (map $f$ $V$) applies the given function $f$ to each element of list $V$, returning a list of the results in the same order, i.e., (map $f$ $V$) = $f(head(V))$::(map $f$ $tail(V$)). 

Assume \Fn$(V,n)=[y_1,\ldots,y_n]$ with $y_1<\cdots< y_n$, where $y_1,\ldots,y_n$ are the minimal $n$ values in list $V$. Then, metamorphic relations of \Fn$(V,n)$ can be defined as follows, in which source test case and follow-up test case are denoted as $I_s$ and $I_f$, respectively.

\subsubsection{Permutation}
A permutation of $V$ is a rearrangement of the elements of list $V$. Such rearrangement shall not affect the result of \Fn. This property is identified as the following metamorphic relations, where $\MR_2$ constitutes a special case of $\MR_1$.
\begin{enumerate}[\MR-1]
\item \Fn$(V',n)=\Fn(V,n)$ for any permuation $V'$ of $V$.

In this MR, $I_f = V'$ is constructed by randomly adjusting the positions of elements in $V$. For example, $V = [1, 2, 3, 4, 5]$, then a $V'$ could be $[5, 4, 3, 1, 2]$. Since all elements in $I_f$ are same as $I_s$, we have $\Fn(V',n)=\Fn(V,n)$.

\item (Commutative Law) \Fn$(WV^*,n)=\Fn(V^*W,n)$.

Consider the $V$ is composed of two sublist $V^*$ and $W$. $I_f$ could be obtained by exchanging the $V^*$ and $W$. For example, $I_s = V^*W$, where $V^* = [1, 2, 3]$ and $W = [4, 5]$, then $I_f$ is obtained by concatenating $V^*$ and $W$, that is $I_f = WV^* = [4, 5, 1, 2, 3]$. All elements in $I_f$ are same as $I_s$, hence, we have $\Fn(WV^*) = \Fn(V^*W)$.
\end{enumerate}

\subsubsection{Insertion}
Adding duplicate elements into list $V$ shall not affect the result of \Fn. This general property is  identified as the following metamorphic relations, which choose duplicate elements from different perspectives.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{2}

\item \Fn$(V^k,n)=\Fn(V,n)$ for any $k>1$.

In this MR, $I_f$ is constructed by concatenating all elements in $I_s = V$ to the end of $I_s$ one by one for $k$ times. As a consequence, $I_f$ has same elements as $I_s$, but is $k$ times the length of $I_s$. Therefore, we have $\Fn(V^k) = \Fn(V,n)$

\item \Fn$(VV',n)=\Fn(V,n)$ for any $V'\subseteq V$.

Suppose $V'$ is any non-empty sublist of $I_s = V$. $I_f$ is constructed by concatenating all elements in $V'$ to the end of $I_s$ one bu one, denoted as $I_f = VV'$. As a consequence, $\forall e_i \in I_f$, we have $e_i \in I_s$. Therefore, $\Fn(VV', n) = \Fn(V, n)$.

\item \Fn$(V[y],n)$=\Fn$(V,n)$ for any $y$ in \Fn$(V,n)$.

Suppose $y \in \Fn(V, n)$. $I_f$ is constructed by concatenating $y$ to the end of $I_s = V$. Because $y \in I_s$, therefore, $\forall e_i \in I_f$, $e_i \in I_s$. Thus, $\Fn(V[y],n)=\Fn(V,n)$.

\item \Fn$(VV_1\cdots V_k,n)=\Fn(V,n)$ for any $k\geq 1$, where $V_i\subseteq\Fn(V,n)$ for every $1\leq i\leq k$.

Suppose $V_i \subseteq \Fn(V,n)$, where $1 \leq i \leq k$, and $k \ge 1$. $I_f$ is constructed by concatenating elements in $V_i$ to the end of $I_s = V$ one by one. Because $V_i \subseteq \Fn(V,n), \Fn(V,n) \subseteq I_s$, therefore, $\forall e_i \in V_i$, we have $e_i \in I_s$, that is $\forall e_i \in I_f$, $e_i \in I_s$. Thus, we have $\Fn(VV_1 \cdots V_k, n) = \Fn(V, n)$.

\item \Fn$(V[y_1, \ldots, y_n],n)=\Fn(V,n)$.

Suppose $[y_1, \ldots, y_n]$ is the tesing result of source test case. $I_f$ is constructed by concatenating elements in $[y_1, \ldots, y_n]$ to the end of $I_s = V$ one by one. Because $[y_1, \ldots, y_n] \subseteq I_s$, therefore, $\forall e_i \in I_f$, we have $e_i \in I_s$. Thus, we have \Fn$(V[y_1, \ldots, y_n],n)=\Fn(V,n)$. 

\item \Fn$(V[y_n,\ldots,y_1],n)=\Fn(V,n)$.

Suppose $[y_1, \ldots, y_n]$ is the tesing result of source test case, and $[y_n, \ldots, y_1]$ is the rearrangement of $[y_1, \ldots, y_n]$ from large to small. $I_f$ is constructed by concatenating elements in $[y_n, \ldots, y_1]$ to the end of $I_s = V$ one by one. Because $[y_n, \ldots, y_1] \subseteq I_s$, therefore, $\forall e_i \in I_f$, we have $e_i \in I_s$. Thus, we have \Fn$(V[y_n, \ldots, y_1],n)=\Fn(V,n)$.

\item \Fn$(VW,n)=\Fn(V,n)$ for any permutation $W$ of \Fn$(V,n)$.

Suppose $[y_1, \ldots, y_n]$ is the tesing result of source test case, and $W$ is any permuation of $[y_1, \ldots, y_n]$ (Note that MR-8 is a special case of MR-9). $I_f$ is constructed by concatenating elements in $W$ to the end of $I_s = V$ one by one. Because $W \subseteq I_s$, therefore, $\forall e_i \in I_f$, we have $e_i \in I_s$. Thus, we have \Fn$(VW,n)=\Fn(V,n)$.

\item \Fn$([y_1,\ldots,y_n]V,n)=\Fn(V,n)$

Suppose $[y_1, \ldots, y_n]$ is the tesing result of source test case. $I_f$ is constructed by concatenating elements in $[y_1, \ldots, y_n]$ to the head of $I_s = V$ one by one. Because $[y_1, \ldots, y_n] \subseteq I_s$, therefore, $\forall e_i \in I_f$, we have $e_i \in I_s$. Thus, we have \Fn$(V[y_1, \ldots, y_n],n)=\Fn(V,n)$.

\item \Fn$([y_n,\ldots,y_1]V,n)=\Fn(V,n)$

Suppose $[y_1, \ldots, y_n]$ is the tesing result of source test case, and $[y_n, \ldots, y_1]$ is the rearrangement of $[y_1, \ldots, y_n]$ from large to small. $I_f$ is constructed by concatenating elements in $[y_n, \ldots, y_1]$ to the head of $I_s = V$ one by one. Because $[y_n, \ldots, y_1] \subseteq I_s$, therefore, $\forall e_i \in I_f$, we have $e_i \in I_s$. Thus, we have \Fn$(V[y_n, \ldots, y_1],n)=\Fn(V,n)$.

\item \Fn$(WV,n)=\Fn(V,n)$ for any permutation $W$ of \Fn$(V,n)$.

Suppose $[y_1, \ldots, y_n]$ is the tesing result of source test case, and $W$ is any permuation of $[y_1, \ldots, y_n]$ (Note that MR-11 is a special case of MR-12). $I_f$ is constructed by concatenating elements in $W$ to the head of $I_s = V$ one by one. Because $W \subseteq I_s$, therefore, $\forall e_i \in I_f$, we have $e_i \in I_s$. Thus, we have \Fn$(VW,n)=\Fn(V,n)$.
\end{enumerate}

The following metamorphic relations add to list $V$ fresh elements that are no greater than the last element $y_n$ of \Fn$(V,n)$. These elements shall occur in the follow-up result of \Fn.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{12}
\item \Fn$(V[y],n)=[y_1,\ldots,y_i,y,y_{i+1},\ldots,y_{n-1}]$ if $y\not\in\Fn(V,n)$ and there exists $1\leq i< n$ such that $y_i<y<y_{i+1}$.

In this MR, $I_f$ is constructed by concatenating element $y$ to the end of $I_s = V$. 

\item \Fn$(V[y_1',\ldots,y_k'],n)=[y_1',\ldots,y_k',y_1,\ldots,y_{n-k}]$, where $k\leq n$ and $y_1'<\cdots< y_k'<y_1$.

In this MR, $I_f$ is constructed by concatenating elements in $[y_1', \ldots, y_k']$ to the head of $I_s = V$ one by one.
\end{enumerate}

On the contrary, the following metamorphic relation \MR-15 adds to list $V$ fresh elements that are greater than $y_n$. This insertion shall not affect the result of \Fn.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{14}
\item \Fn$(V[y_1'',\ldots,y_k''],n)=\Fn(V,n)$, where $y_n<y_1''\leq\cdots\leq y_k''$.

In this MR, $I_f$ is constructed by concatenating elements in $[y_1'', \ldots, y_k'']$ to the head of $I_s = V$ one by one.
\end{enumerate}

\subsubsection{Deletion}
Deleting an element from list $V$ will change the result of \Fn~if it also occurs in \Fn$(V,n)$. The follow-up result of \Fn~only differs from the original one in those elements deleted.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{15}
\item\label{mr-del}Let $X=[x_1,\ldots,x_k]$ for arbitrary $k\geq 1$  elements $x_1,\ldots,x_k$, $V'=V\backslash X$, $X'=X\cap\Fn(V,n)$.
\begin{itemize}
\item Then, $\Fn(V,n)\backslash\Fn(V',n)\subseteq X'$
\item Specially, if $X'=\emptyset$, $\Fn(V',n)=\Fn(V,n)$;
\end{itemize} 
\end{enumerate}
where $V\backslash X$  removes from $V$ only one occurrence of each element in $X$ (if any).

In this MR, $I_f$ is constructed by delecting elements in $V \cap X$. To explore the relations between $\Fn(V,n)$ and $\Fn(V',n)$, we first consider the following situations.
\begin{enumerate}[{Situation} 1:]
\item
$V \cap X = \emptyset$, then we have $V' = V$. Because $\Fn(V,n) \subseteq V$ and $V \cap X = \emptyset$, therefore $X' = \emptyset$. Also, because $\Fn(V,n) = \Fn(V',n)$, therefore $\Fn(V,n)\backslash\Fn(V',n) = \emptyset$. Obviously, $\Fn(V,n)\backslash\Fn(V',n)\subseteq X'$.
\item
$V \cap X \neq \emptyset, X \cap \Fn(V,n) = \emptyset$, then $X' = \emptyset$. $\forall e_i' \in \Fn(V,n)$, we have $e_i' \notin X$, $e_i' \in V'$, which gives $\Fn(V,n) \subseteq V'$. Because, $V' \subseteq V$, therefore, $\Fn(V',n) = \Fn(V,n)$. 
\item
$V \cap X \neq \emptyset, X \cap \Fn(V,n) \neq \emptyset$, that is $\exists e_i \in \Fn(V,n)$, subject to $e_i \notin V'$, and $e_i \in X'$. Suppose $B = \Fn(V,n) \backslash X'$, we have $B \subseteq V'$. Because $B \subseteq \Fn(V',n)$, therefore, $B \subseteq \Fn(V',n)$. Also, because $B + X' = \Fn(V,n)$, therefore, $\Fn(V,n) \backslash \Fn(V',n) = X'$, and thus $\Fn(V,n) \backslash \Fn(V',n) \subseteq X'$.
\end{enumerate}

\subsubsection{Transformation}
Transforming all the elements of list $V$ will make the result of \Fn~transformed in the same way.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{16}
\item \Fn((map $f$ $V$),n)=(map $f$ \Fn($V$,$n$)). For example, $f(x)=x+c$ for any constant $c$.
\end{enumerate} 

\subsubsection{Splitting}
Suppose $V=V_1V_2$. If $y$ is one of the minimal $n$ values in list $V$, then it is also one of the minimal $n$ values in list $V_1$ or $V_2$. This property is identified as the following metamorphic relation \MR-18.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{17}
\item \Fn$(V,n)\subseteq\Fn(V_1,n)\cup\Fn(V_2,n)$.
\end{enumerate}

In this MR, $I_f$ is constructed by splitting $V$ into $V_1$ and $V_2$. Because $V_1 \cup V_2 = V$, therefore, $\exists A \subseteq \Fn(V_1,n), B \subseteq \Fn(V_2,n)$, subject to $A \cup B = \Fn(V,n)$. Aboviously, $A \cup B \subseteq \Fn(V_1,n) \cup \Fn(V_2,n)$, from which we can obtain $\Fn(V,n) \subseteq \Fn(v_1,n) \cup \Fn(V_2,n)$.


If $y$ is one of the minimal $n$ values in list $V_1$, and also one of the minimal $m$ values in list $V_2$, then it is one of the minimal $n+m$ values in list $V$. This property is identified as the following metamorphic relations, which differ only in $m$.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{18}
\item \Fn$(V_1, n)\cap \Fn(V_2, n)\subseteq \Fn(V, 2n)$.
\item \Fn$(V_1, n)\cap \Fn(V_2, m)\subseteq \Fn(V, n+m)$ for $1\leq m<n$.
\item \Fn$(V_1, n)\cap \Fn(V_2, m)\subseteq \Fn(V, n+m)$ for $m>n$.
\end{enumerate}

The concatenation of the results of \Fn~on $V_1$ and $V_2$ preserves the result of $\Fn$ on $V$. This property is identified as the following metamorphic relation \MR-22.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{21}
\item \Fn$(V,n)$=$\Fn(\Fn(V_1,n)\Fn(V_2,n),n)$.
\end{enumerate}

\subsubsection{Sublisting}
\Fn$(V,n)$ is a prefix of \Fn$(V,m)$ if $n<m$, while \Fn$(V,n)$ is an extension of \Fn$(V,m)$ if $n>m$. Specially, we consider the boundary values of $m$ in the following metamorphic relations.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{22}
\item \Fn$(V,n)$ is a prefix of \Fn$(V,n+1)$.
\item \Fn$(V,n)$ is a prefix of \Fn$(V,m)$ if $m>n+1$.
\item \Fn$(V,n)$ is an extension of \Fn$(V,n-1)$.  
\item \Fn$(V,n)$ is an extension of \Fn$(V,m)$ if $1\leq m<n-1$.  
\end{enumerate}


\section{Empirical Study}
\label{section:empirical}
In this section we present the research questions concerned in this work, and the case study on the concurrent implementations of \Fn($V,n$). Then, we discuss the experimental results with detailed analysis.

\subsection{Research Questions}
\label{section:questions}

\begin{enumerate}[RQ-1]
\item

How effective MT is at detecting faults of concurrent programs? What is the actual overhead for MT detecting these faults, in terms of time consumption and the number of test cases executed?

Fault-detection effectiveness and efficiency are key for evaluating the performance of a testing technique. In our study, we adopt five state-of-the-art concurrent priority queue classes to implement the function \Fn($V,n$) within various concurrent scenarios. Then, we apply mutation analysis to evaluate the performance of MT in detecting the faults seeded, especially the concurrency faults related  to locks and atomic primitives.
\item
What is the fault-detecting capability of an individual metamorphic relation in different concurrent scenarios? How are metamorphic relations relevant to programs faults, especially concurrency faults?

\item
How many threads are sufficient for MT detecting a concurrency fault? 

\item
How many metamorphic relations are sufficient for MT detecting the faults that remain in a concurrent program? ({\color{red}probably not in this paper})

\end{enumerate}

\subsection{Object Programs}
\label{sec:programs}

In our study, we selected 5 concurrent priority queues named \texttt{SimpleLinear}, \texttt{SimpleTree}, \texttt{SequentialHeap},
\texttt{FineGrainedHeap}, and \texttt{SkipQueue}, utilized as the data repository to be shared by multiple threads, which are present in textbook \cite{PQUEUE}. All source codes of used object programs can be obtained by visiting the following address: https://booksite.elsevier.com/9780123973375/. We employed mutation analysis \cite{demillo1978hints, sun2017path} to evaluate the fault-detection effectiveness of proposed method.  We first used the tool MuJava \cite{ma2005mujava} and Major \cite{Just2014} to generate traditional mutants, and then artificial created concurrent mutants according to 24 concurrent mutation operators proposed by \cite{bradbury2006mutation}. Each traditional mutant and concurrent mutant was created by applying a syntactic change (using one of all applicable mutation operators provided by MuJava, Major and \cite{bradbury2006mutation}, respectively) to the original program. The same mutants generated by Major and Mujava are identified and removed by created script. Equivalent mutants are identified and removed by executing all test cases and artifical checking mutants that cannot be killed. Table \ref{tab:programs} summarizes the basic information of the used programs and their mutants. A detailed description of each program is given in the following.

\begin{table}[h]
\caption{Subject Programs}
\label{tab:programs}
\renewcommand\tabcolsep{5.0pt}
\begin{tabular}{llll} \toprule
Programs                   &LOC               & Number of             & Number of  \\ 
                           &                  & traditional mutants   & concurrent mutants \\ \midrule
\texttt{SimpleLinear}      &119               & 22                    & 2 \\ 
\texttt{SimpleTree}        &109               & 50                    & 4 \\ 
\texttt{SequentialHeap}    &155               & 240                   & 2 \\ 
\texttt{FineGrainedHeap}   &259               & 222                   & 40 \\ 
\texttt{SkipQueue}         &312               & 129                   & 8 \\ \bottomrule
\end{tabular}
\end{table}

\subsubsection{SimpleLinear}
\label{sec:simpleLinear}





\subsection{Experimental Results}

\subsubsection{Mutants}
\label{section:mutants}


\subsubsection{Concurrent Scenarios}
\subsubsection{Response to RQ-1}
\subsubsection{Response to RQ-2}
\subsubsection{Response to RQ-3}

\section{Related Work}
\label{section:related}
In this section, we describe related work of MT.

\subsection{Metamorphic Testing}
When testing a software system, the oracle problem appears in some situations where either an oracle does not exist for the tester to verify the correctness of the computed results; or an oracle does exist but cannot be used. The oracle problem often occurs in software testing, which renders many testing techniques inapplicable \cite{barr2015oracle}. To alleviate the oracle problem, Chen et al. \cite{chen1998metamorphic} proposed a technique named metamorphic testing (MT) that has been receiving increasing attention in the software testing community\cite{barr2015oracle, segura2016survey, chen2018metamorphic}. The main contributions to MT in the literature focused on the following aspects: \rmnum{1}) MT theory; \rmnum{2}) combination with other techniques; \rmnum{3}) application of MT.
\begin{enumerate}[1]
  \item
  \emph{Theoretical development of MT:} The MRs and the source test cases are the most important components of MT. However, defining MRs can be difficult. Chen et al. \cite{chen2016metric} proposed a specification-based method and developed a tool called MR-GENerator for identifying MRs based on category-choice framework\cite{ostrand1988category}.
  Zhang et al. \cite{zhang2014search} proposed a search-based approach to automatic inference of polynomial MRs for a software under test, where a set of parameters is used to represent polynomial MRs, and the problem of inferring MRs is turn into a problem of searching for suitable values of the parameters. Then, particle swarm optimization is used to solve the search problem.
  Sun et al. \cite{sun2016mumt} proposes a data-mutation directed metamorphic relation acquisition methodology, in which data mutation is employed to construct input relations and the generic mapping rule associated with each mutation operator to construct output relations.
  Liu et al. \cite{liu2012new} proposed to systematically construct MRs based on some already identified MRs.

  Without doubt, ``good'' MRs can improve the fault detection efficiency of MT.
  Chen et al. \cite{chen2004case} reported that good MRs are those that can make the execution of the source-test case as different as possible to its follow-up test case.
  This perspective has been confirmed by the later studies \cite{dong2013security, batra2011efficient}.
  Asrafi et al. \cite{asrafi2011testing} conduct a case study to analyze the relationship between the execution behavior and the fault-detection effectiveness of metamorphic relations by code coverage criteria, and the results showed a strong correlation between the code coverage achieved by a metamorphic relation and its fault-detection effectiveness.

  Source test cases also have a important impact on the fault detection effectiveness of MT.
  Chen et al. \cite{chen2004metamorphic} compared the effects of source test cases generated by special value testing and random testing on the effectiveness of MT, and found that MT can be used as a complementary test method to special value testing.
  Batra and  Sengupta \cite{batra2011efficient} integrated genetic algorithms into MT to select source test cases maximising the the paths traversed in the software under test.
  Dong et al. \cite{dong2013security} proposed a Path--Combination--Based MT method that first generates symbolic input for each executable paths and minis relationships among these symbolic inputs and their outputs, then constructs MRs on the basis of these relationships, and generates actual test cases corresponding to the symbolic inputs.

  Different from the above investigates, we focused on performing test cases and MRs with fault revealing capabilities as quickly as possible by making use of feedback information. We first divided the input domain into disjoint partitions, and randomly selected an MR to generate follow-up test cases depended on source test case of related input partitions, then updated the test profile of input partitions according to the results of test execution. Next, a partition was selected according to updated test profile, and an MR was randomly selected from the set of MRs whose source test cases belong to selected partition.
  \item
  \emph{Combination with other techniques:} In order to improve the applicability and effectiveness of MT, it has been integrated into other techniques.
  Xie et al. \cite{xie2013metamorphic} combined the MT with the spectrum-based fault localization (SBFL), extend the application of SBFL to the common situations where test oracles do not exist.
  Dong et al. \cite{dong2010security} proposed a method for improving the efficiency of evolutionary testing (ET) by considering MR when fitness function is constructed.
  Liu et al. \cite{liu2014metamorphic} introduced MT into fault tolerance and proposed a theoretical framework of a new technique called Metamorphic Fault Tolerance (MFT), which can
  handle system failure without the need of oracles during failure detection. In MFT, the trustworthiness of a test case depends on the number of violations or satisfactions of metamorphic relations. The more relations are satisfied and the less relations are violated, the more trustable test case is.
  \item
  \emph{Application of MT:}
  Sun et al. \cite{sun2011metamorphic, sun2012metamorphic} proposed a metamorphic testing framework for web services taking into account the unique features of SOA, in which MRs are derived from the description or Web Service Description Language (WSDL) \cite{sun2011metamorphic} of the Web service, and on the basis on of MRs, follow-up test cses are generated depended on source test cases that are randomly generated according to the WSDL.
  Segura et al. \cite{segura2018metamorphic} present a metamorphic testing approach for the detection of faults in RESTful Web APIs where they proposed six abstract relations called Metamorphic Relation Output Patterns (MROPs) that can then be instantiated into one or more concrete metamorphic relations. To evaluate this approach, they used both automatically seeded and real faults in six subject Web APIs.

\end{enumerate}



\section{Conclusion}
\label{section:conclusion}


In our future work, we plan to conduct experiments on more real-life programs to further validate the effectiveness of MT, and identify the limitations of our approach.

\section*{Acknowledgment}


\newcommand{\BIBdecl}{\setlength{\itemsep}{0.2 em}}

\bibliographystyle{IEEEtran}
\bibliography{CMT}


\end{document}

\section{Background}
In this section, we present the basics to understand our approach. we start with a brief introduction to metamorphic testing, and then describe dynamic random testing.
\label{section:background}
\subsection{Metamorphic Testing}
\label{section:mt}
A test oracle is a mechanism used to verify the correctness of outputs of a program \cite{weyuker1982testing}. However, there are test oracle problem
\cite{barr2015oracle, patel2018mapping} in testing, that is, there are not an oracle or the application of such an oracle is very expensive. In order to alleviate the test oracle,
several techniques have been proposed such as N-version testing \cite{brilliant1990performance}, metamorphic testing (MT) \cite{chen1998metamorphic},
assertions \cite{sim2014eliminating}, machine learning \cite{chan2009pat}, etc. Among of them, MT obtains metamorphic relations (MRs) according to the properties of software
under test (SUT). MRs are used to generate follow-up test cases from source test cases, then the both source and follow-up test cases are executed, and their results are
verified against the corresponding MRs. If an MR is violated, that is, a fault is detected.



