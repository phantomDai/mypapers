\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{amsthm}
\theoremstyle{remark}
\newtheorem*{rmk*}{Remark}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{enumerate}
\usepackage{multirow}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\newcommand{\rmnum}[1]{\expandafter{\romannumeral #1\relax}}
\newcommand{\Fn}{\textsc{top}}
\newcommand{\MR}{\textit{MR}}
\begin{document}

\title{Towards Metamorphic Testing of Concurrent Programs\\
%{\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and
%should not be used}
%\thanks{Identify applicable funding agency here. If none, delete this.}
\thanks{The National Natural Science Foundation of China (under Grant No. 61872039),
the Beijing Natural Science Foundation (Grant No. 4162040),
the Aeronautical Science Foundation of China (Grant No. 2016ZD74004), and
the Fundamental Research Funds for the Central Universities (Grant No. FRF-GF-17-B29).}
}

\author{\IEEEauthorblockN{Peng~Wu}
\IEEEauthorblockA{\textit{State Key Laboratory of Computer Science} \\
\textit{Institute of Software, Chinese Academy of Sciences} \\
\textit{University of Chinese Academy of Sciences}\\
Beijing, China, wp@ios.ac.cn}
\and
\IEEEauthorblockN{Hepeng~Dai}
\IEEEauthorblockA{\textit{School of Computer and Communication Engineering} \\
\textit{University of Science and Technology Beijing}\\
Beijing, China \\
daihepeng@xs.ustb.edu.cn}
\and
\IEEEauthorblockN{Tsong Yueh Chen}
\IEEEauthorblockA{\textit{Department of Computer Science and Software Engineering} \\
\textit{Swinburne University of Technology}\\
Melbourne, Australia \\
tychen@swin.edu.au}
\and
\IEEEauthorblockN{Chang-ai~Sun,~\IEEEmembership{Member,~IEEE}}
\IEEEauthorblockA{\textit{School of Computer and Communication Engineering} \\
\textit{University of Science and Technology Beijing}\\
Beijing, China \\
casun@ustb.edu.cn}
}

\maketitle

\begin{abstract}
  Metamorphic testing (MT) is a promising technique to alleviate the oracle problem, which fist defines metamorphic relations (MRs) used to generate new test cases (i.e. follow-up
  test cases) from the original test cases (i.e. source test cases). Both source and follow-up test cases are executed and their results are verified against the relevant MRs.

\end{abstract}

\begin{IEEEkeywords}
metamorphic testing, control test process, partition
\end{IEEEkeywords}

\section{Introduction}
\label{section:introduction}
Testing of a concurrent program, e.g., a multi-threaded program, is still a challenging task due to its nature of nondeterminism. Moreover, a concurrent program typically consists of multiple threads that cooperate closely to fulfill a functional assignment with high efficiency, e.g., computing, sorting, or searching a large volume of static or dynamic data. A test oracle \cite{weyuker1982testing} usually provides an exact mechanism of deciding whether an output
produced by a program is correct or not. This oracle problem \cite{barr2015oracle, patel2018mapping} also arises for concurrent programs as it can be very difficult or expensive, if not impossible, to determine their expected outputs \textit{a priori}.

Metamorphic testing (MT) \cite{chen1998metamorphic, chen2018metamorphic} has been a successful technique to tackle oracle problems in various domains. It first defines metamorphic relations (MRs)
based on the necessary properties about the inputs and outputs of the program under test. Then, MRs are exploited in two ways: a new test case (i.e., a follow-up test case) can be generated from an original test case (i.e., a source test case) based on an MR; the outputs resulted by executing the source and follow-up test cases can be verified against the corresponding MR. If the MR is violated, the program under test is shown to be incorrect, as witnessed by the pair of the source and follow-up test cases.

Let us use a simple example to illustrate how MT works. For instance, consider the function $max(x,y)$ that returns the maximum value between two integers $x$ and $y$. It enjoys a simple and obvious property that the order of the two parameters $x$ and $y$ shall not affect the outputs. This can be identified as the metamorphic relation $\MR_{max}: max(x,y) = max(y,x)$, where $(x,y)$ and $(y,x)$ constitutes the source and the follow-up test case, respectively. Then, given a program $P(x,y)$ that implements the function $max(x,y)$, and a source test case $(1,2)$, if the outputs of $P$ running with this source test case and the follow-up test case $(2,1)$ do not equal, i.e, $P(1,2)\neq P(2,1)$, a fault is detected in $P$.

In this paper we aim at investigating the applicability of metamorphic testing to concurrent programs. This is motivated by the observation that the functional requirement or user expectation to a concurrent program can be identified as metamorphic relations for verifying the outputs of its nondeterministic executions under different inputs.

The rest of the paper is organized as follows.

\section{Metamorphic Testing of Concurrent Programs}
\subsection{Concurrent Programs}

Consider a function \Fn$(V,n)$ that returns in the ascending order the minimal $n$ values in a list $V$, while $V$ may contain duplicate elements. For a list of large size, a sequential search program may not implement this function in a highly efficient way. Many concurrent search structures have been proposed to take advantages of multi-processor architectures, which are already very popular nowadays. Concurrent implementations of the \emph{priority queue} data structure are typically adopted to implement multi-threaded programs for the function \Fn$(V,n)$. In this work, we use the 5 concurrent priority queue classes presented in the textbook \cite{PQUEUE}: SimpleLinear, SimpleTree, SequentialHeap, FineGrainedHeap, and SkipQueue.

The SimpleLinear class is an array-based bounded implementation, while the SimpleTree class is a tree-based one. The SequentialHeap class is a coarse-grained implementation based on a unbounded heap, while the FineGrainedHeap class is a fine-grained one. These four classes all explicitly use locks for synchronization, while the SkipQueue class does not. It is based on a skiplist that uses atomic primitives (i.e., compareAndSet) for synchronization.

\subsection{Metamorphic Relations}
Let $VW$ be the concatenation of lists $V$ and $W$, and $V^k$ the concatenation of $k$ $V$'s. Let $head(V)$ denote the first element of list $V$, and $tail(V)$ the list resulted by removing the first element of list $V$. Therefore, $V=head(V)::tail(V)$. The higher-order function  (map $f$ $V$) applies the given function $f$ to each element of list $V$, returning a list of the results in the same order, i.e., (map $f$ $V$) = $f(head(V))$::(map $f$ $tail(V$)).

Assume \Fn$(V,n)=[y_1,\ldots,y_n]$ with $y_1<\cdots< y_n$, where $y_1,\ldots,y_n$ are the minimal $n$ values in list $V$. Then, metamorphic relations of \Fn$(V,n)$ can be defined as follows.

\subsubsection{Permutation}
A permutation of $V$ is a rearrangement of the elements of list $V$. Such rearrangement shall not affect the result of \Fn. This property is identified as the following metamorphic relations, where $\MR_2$ constitutes a special case of $\MR_1$.
\begin{enumerate}[\MR-1]
\item \Fn$(V',n)=\Fn(V,n)$ for any permuation $V'$ of $V$.
\item (Commutative Law) \Fn$(VW,n)=\Fn(WV,n)$.
\end{enumerate}
%Permutation can be combined with other metamorphic relations.

\subsubsection{Insertion}
Adding duplicate elements into list $V$ shall not affect the result of \Fn. This general property is  identified as the following metamorphic relations, which choose duplicate elements from different perspectives.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{2}
\item \Fn$(V^k,n)=\Fn(V,n)$ for any $k>1$.
\item \Fn$(VV',n)=\Fn(V,n)$ for any $V'\subseteq V$.
\item \Fn$(V[y],n)$=\Fn$(V,n)$ for any $y$ in \Fn$(V,n)$.
\item \Fn$(VV_1\cdots V_k,n)=\Fn(V,n)$ for any $k\geq 1$, where $V_i\subseteq\Fn(V,n)$ for every $1\leq i\leq k$.
\item \Fn$(V[y_1,\ldots,y_n],n)=\Fn(V,n)$.
\item \Fn$(V[y_n,\ldots,y_1],n)=\Fn(V,n)$.
\item \Fn$(VW,n)=\Fn(V,n)$ for any permutation $W$ of \Fn$(V,n)$.
\item \Fn$([y_1,\ldots,y_n]V,n)=\Fn(V,n)$
\item \Fn$([y_n,\ldots,y_1]V,n)=\Fn(V,n)$
\item \Fn$(WV,n)=\Fn(V,n)$ for any permutation $W$ of \Fn$(V,n)$.
\end{enumerate}

The following metamorphic relations add to list $V$ fresh elements that are no greater than the last element $y_n$ of \Fn$(V,n)$. These elements shall occur in the follow-up result of \Fn.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{12}
\item \Fn$(V[y],n)=[y_1,\ldots,y_i,y,y_{i+1},\ldots,y_{n-1}]$ if $y\not\in\Fn(V,n)$ and there exists $1\leq i< n$ such that $y_i<y<y_{i+1}$.
\item \Fn$(V[y_1',\ldots,y_k'],n)=[y_1',\ldots,y_k',y_1,\ldots,y_{n-k}]$, where $k\leq n$ and $y_1'<\cdots< y_k'<y_1$.
\end{enumerate}

On the contrary, the following metamorphic relation \MR-15 adds to list $V$ fresh elements that are greater than $y_n$. This insertion shall not affect the result of \Fn.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{14}
\item \Fn$(V[y_1'',\ldots,y_k''],n)=\Fn(V,n)$, where $y_n<y_1''\leq\cdots\leq y_k''$.
\end{enumerate}

\subsubsection{Deletion}
Deleting an element from list $V$ will change the result of \Fn~if it also occurs in \Fn$(V,n)$. The follow-up result of \Fn~only differs from the original one in those elements deleted.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{15}
\item\label{mr-del}Let $X=[x_1,\ldots,x_k]$ for arbitrary $k\geq 1$  elements $x_1,\ldots,x_k$, $V'=V\backslash X$, $X'=X\cap\Fn(V,n)$.
\begin{itemize}
\item Then, $\Fn(V,n)\backslash\Fn(V',n)\subseteq X'$
\item Specially, if $X'=\emptyset$, $\Fn(V',n)=\Fn(V,n)$;
\end{itemize}
\end{enumerate}
where $V\backslash X$  removes from $V$ only one occurrence of each element in $X$ (if any).
%\begin{rmk*}
%A major concern with \textit{MR}-\ref{mr-del} is that the construction of the follow-up $V¡¯$ may be expensive.\qed
%\end{rmk*}

\subsubsection{Transformation}
Transforming all the elements of list $V$ will make the result of \Fn~transformed in the same way.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{16}
\item \Fn((map $f$ $V$),n)=(map $f$ \Fn($V$,$n$)). For example, $f(x)=x+c$ for any constant $c$.
\end{enumerate}

\subsubsection{Splitting}
Suppose $V=V_1V_2$. If $y$ is one of the minimal $n$ values in list $V$, then it is also one of the minimal $n$ values in list $V_1$ or $V_2$. This property is identified as the following metamorphic relation \MR-18.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{17}
\item \Fn$(V,n)\subseteq\Fn(V_1,n)\cup\Fn(V_2,n)$.
\end{enumerate}

If $y$ is one of the minimal $n$ values in list $V_1$, and also one of the minimal $m$ values in list $V_2$, then it is one of the minimal $n+m$ values in list $V$. This property is identified as the following metamorphic relations, which differ only in $m$.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{18}
\item \Fn$(V_1, n)\cap \Fn(V_2, n)\subseteq \Fn(V, 2n)$.
\item \Fn$(V_1, n)\cap \Fn(V_2, m)\subseteq \Fn(V, n+m)$ for $1\leq m<n$.
\item \Fn$(V_1, n)\cap \Fn(V_2, m)\subseteq \Fn(V, n+m)$ for $m>n$.
\end{enumerate}

The concatenation of the results of \Fn~on $V_1$ and $V_2$ preserves the result of $\Fn$ on $V$. This property is identified as the following metamorphic relation \MR-22.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{21}
\item \Fn$(V,n)$=$\Fn(\Fn(V_1,n)\Fn(V_2,n),n)$.
\end{enumerate}

\subsubsection{Sublisting}
\Fn$(V,n)$ is a prefix of \Fn$(V,m)$ if $n<m$, while \Fn$(V,n)$ is an extension of \Fn$(V,m)$ if $n>m$. Specially, we consider the boundary values of $m$ in the following metamorphic relations.
\begin{enumerate}[\MR-1]
\setcounter{enumi}{22}
\item \Fn$(V,n)$ is a prefix of \Fn$(V,n+1)$.
\item \Fn$(V,n)$ is a prefix of \Fn$(V,m)$ if $m>n+1$.
\item \Fn$(V,n)$ is an extension of \Fn$(V,n-1)$.
\item \Fn$(V,n)$ is an extension of \Fn$(V,m)$ if $1\leq m<n-1$.
\end{enumerate}

%\begin{rmk*}
%If the number of values contained in $V$ is less than $n$, then \Fn$(V,n)$ shall return all the values in $V$ in the ascending order. We need to check whether the above MRs still hold.\qed
%\end{rmk*}

\section{Empirical Study}
\label{section:empirical}
In this section we present the research questions concerned in this work, and the case study on the concurrent implementations of \Fn($V,n$). Then, we discuss the experimental results with detailed analysis.

\subsection{Research Questions}
\label{section:questions}

\begin{enumerate}[RQ-1]
\item
How effective MT is at detecting faults of concurrent programs? What is the actual overhead for MT detecting these faults, in terms of time consumption and the number of test cases executed?

Fault-detection effectiveness and efficiency are key for evaluating the performance of a testing technique. In our study, we adopt three state-of-the-art concurrent priority queue classes to implement the function \Fn($V,n$) within various concurrent scenarios. Then, we apply mutation analysis to evaluate the performance of MT in detecting the faults seeded, especially the concurrency faults related  to locks and atomic primitives.
\item
What is the fault-detecting capability of an individual metamorphic relation in different concurrent scenarios? How are metamorphic relations relevant to programs faults, especially concurrency faults?

\item
How many threads are sufficient for MT detecting a concurrency fault?

%\item
%How many metamorphic relations are sufficient for MT detecting the faults that remain in a concurrent program? ({\color{red}probably not in this paper})

\end{enumerate}

\subsection{Experimental Results}

\subsubsection{Mutants}
\label{section:mutants}
Mutation analysis \cite{demillo1978hints} has been widely used to asses the adequacy of test suites and the effectiveness of testing techniques. Mutation operators are used to seed various faults into the program under test, and thus generate a set of variants (i.e. mutants). If a test case causes a mutant to behave differently to the program under test, then we say that the mutant is ``killed'' by the test case. The mutation score ($MS$) is used to measure how thoroughly a test suite ``kills'' the mutants.

\begin{equation}
\label{}
  
\end{equation}

We selected three state-of-the-art concurrent priority queue classes as the subject programs for our study: \texttt{SimpleLinear}, \texttt{SimpleTree}, and \texttt{SequentialHeap}. We used mutation analysis \cite{demillo1978hints} to generate a total of 320 mutants, which includes 312 traditional mutants and 8 concurrent mutants. Each mutants was created by applying a syntactic change (i.e. traditional mutation operator and concurrent mutation operator \cite{Bradbury2006}). Table \ref{table:programs} summarizes the basic information of the used programs and their mutants.

\begin{table}[hbt]
  \caption{Object programs}
  \label{table:programs}
  \centering
  \begin{tabular}{|c|c|c|c|} \hline
    Programs                &LOC   &Number of                   &Number of   \\
                            &      &Traditional Mutants         &Concurrent Mutants  \\ \hline
    \texttt{SimpleLinear}   &52    &22                          &2                    \\  \hline
    \texttt{SimpleTree}     &85    &52                          &4                   \\ \hline
    \texttt{SequentialHeap} &131   &240                         &2                  \\ \hline
  \end{tabular}

\end{table}
\subsubsection{Concurrent Scenarios}
\subsubsection{Response to RQ-1}

The detailed experimental results  

\subsubsection{Response to RQ-2}
\subsubsection{Response to RQ-3}

\section{Related Work}
\label{section:related}
In this section, we describe related work of MT.

\subsection{Metamorphic Testing}
When testing a software system, the oracle problem appears in some situations where either an oracle does not exist for the tester to verify the correctness of the computed results; or an oracle does exist but cannot be used. The oracle problem often occurs in software testing, which renders many testing techniques inapplicable \cite{barr2015oracle}. To alleviate the oracle problem, Chen et al. \cite{chen1998metamorphic} proposed a technique named metamorphic testing (MT) that has been receiving increasing attention in the software testing community\cite{barr2015oracle, segura2016survey, chen2018metamorphic}. The main contributions to MT in the literature focused on the following aspects: \rmnum{1}) MT theory; \rmnum{2}) combination with other techniques; \rmnum{3}) application of MT.
\begin{enumerate}[1]
  \item
  \emph{Theoretical development of MT:} The MRs and the source test cases are the most important components of MT. However, defining MRs can be difficult. Chen et al. \cite{chen2016metric} proposed a specification-based method and developed a tool called MR-GENerator for identifying MRs based on category-choice framework\cite{ostrand1988category}.
  Zhang et al. \cite{zhang2014search} proposed a search-based approach to automatic inference of polynomial MRs for a software under test, where a set of parameters is used to represent polynomial MRs, and the problem of inferring MRs is turn into a problem of searching for suitable values of the parameters. Then, particle swarm optimization is used to solve the search problem.
  Sun et al. \cite{sun2016mumt} proposes a data-mutation directed metamorphic relation acquisition methodology, in which data mutation is employed to construct input relations and the generic mapping rule associated with each mutation operator to construct output relations.
  Liu et al. \cite{liu2012new} proposed to systematically construct MRs based on some already identified MRs.

  Without doubt, ``good'' MRs can improve the fault detection efficiency of MT.
  Chen et al. \cite{chen2004case} reported that good MRs are those that can make the execution of the source-test case as different as possible to its follow-up test case.
  This perspective has been confirmed by the later studies \cite{dong2013security, batra2011efficient}.
  Asrafi et al. \cite{asrafi2011testing} conduct a case study to analyze the relationship between the execution behavior and the fault-detection effectiveness of metamorphic relations by code coverage criteria, and the results showed a strong correlation between the code coverage achieved by a metamorphic relation and its fault-detection effectiveness.

  Source test cases also have a important impact on the fault detection effectiveness of MT.
  Chen et al. \cite{chen2004metamorphic} compared the effects of source test cases generated by special value testing and random testing on the effectiveness of MT, and found that MT can be used as a complementary test method to special value testing.
  Batra and  Sengupta \cite{batra2011efficient} integrated genetic algorithms into MT to select source test cases maximising the the paths traversed in the software under test.
  Dong et al. \cite{dong2013security} proposed a Path--Combination--Based MT method that first generates symbolic input for each executable paths and minis relationships among these symbolic inputs and their outputs, then constructs MRs on the basis of these relationships, and generates actual test cases corresponding to the symbolic inputs.

  Different from the above investigates, we focused on performing test cases and MRs with fault revealing capabilities as quickly as possible by making use of feedback information. We first divided the input domain into disjoint partitions, and randomly selected an MR to generate follow-up test cases depended on source test case of related input partitions, then updated the test profile of input partitions according to the results of test execution. Next, a partition was selected according to updated test profile, and an MR was randomly selected from the set of MRs whose source test cases belong to selected partition.
  \item
  \emph{Combination with other techniques:} In order to improve the applicability and effectiveness of MT, it has been integrated into other techniques.
  Xie et al. \cite{xie2013metamorphic} combined the MT with the spectrum-based fault localization (SBFL), extend the application of SBFL to the common situations where test oracles do not exist.
  Dong et al. \cite{dong2010security} proposed a method for improving the efficiency of evolutionary testing (ET) by considering MR when fitness function is constructed.
  Liu et al. \cite{liu2014metamorphic} introduced MT into fault tolerance and proposed a theoretical framework of a new technique called Metamorphic Fault Tolerance (MFT), which can
  handle system failure without the need of oracles during failure detection. In MFT, the trustworthiness of a test case depends on the number of violations or satisfactions of metamorphic relations. The more relations are satisfied and the less relations are violated, the more trustable test case is.
  \item
  \emph{Application of MT:}
  Sun et al. \cite{sun2011metamorphic, sun2012metamorphic} proposed a metamorphic testing framework for web services taking into account the unique features of SOA, in which MRs are derived from the description or Web Service Description Language (WSDL) \cite{sun2011metamorphic} of the Web service, and on the basis on of MRs, follow-up test cses are generated depended on source test cases that are randomly generated according to the WSDL.
  Segura et al. \cite{segura2018metamorphic} present a metamorphic testing approach for the detection of faults in RESTful Web APIs where they proposed six abstract relations called Metamorphic Relation Output Patterns (MROPs) that can then be instantiated into one or more concrete metamorphic relations. To evaluate this approach, they used both automatically seeded and real faults in six subject Web APIs.

\end{enumerate}



\section{Conclusion}
\label{section:conclusion}


In our future work, we plan to conduct experiments on more real-life programs to further validate the effectiveness of MT, and identify the limitations of our approach.

\section*{Acknowledgment}


\newcommand{\BIBdecl}{\setlength{\itemsep}{0.2 em}}

\bibliographystyle{IEEEtran}
\bibliography{CMT}


\end{document}

\section{Background}
In this section, we present the basics to understand our approach. we start with a brief introduction to metamorphic testing, and then describe dynamic random testing.
\label{section:background}
\subsection{Metamorphic Testing}
\label{section:mt}
A test oracle is a mechanism used to verify the correctness of outputs of a program \cite{weyuker1982testing}. However, there are test oracle problem
\cite{barr2015oracle, patel2018mapping} in testing, that is, there are not an oracle or the application of such an oracle is very expensive. In order to alleviate the test oracle,
several techniques have been proposed such as N-version testing \cite{brilliant1990performance}, metamorphic testing (MT) \cite{chen1998metamorphic},
assertions \cite{sim2014eliminating}, machine learning \cite{chan2009pat}, etc. Among of them, MT obtains metamorphic relations (MRs) according to the properties of software
under test (SUT). MRs are used to generate follow-up test cases from source test cases, then the both source and follow-up test cases are executed, and their results are
verified against the corresponding MRs. If an MR is violated, that is, a fault is detected.


